#include <stdio.h>
#include <stdint.h>

#define W 160
#define H 120

__sfr __at(0xc1) uart;
__sfr __at(0xc2) uart_flag;
__sfr __at(0xc4) vgacolorL;
__sfr __at(0xc4) vgacolorH;
__sfr __at(0xc4) vgaHV;
__sfr __at(0x90) spi;

static __data uint8_t spi_data;
#define SPI_CLK_0 spi_data &= 0xfe; spi = spi_data;
#define SPI_CLK_1 spi_data |= 0x01; spi = spi_data;
#define SPI_CS_0 spi_data &= 0xfd; spi = spi_data;
#define SPI_CS_1 spi_data |= 0x02; spi = spi_data;
#define SPI_DI_0 spi_data &= 0xfb; spi = spi_data;
#define SPI_DI_1 spi_data |= 0x04; spi = spi_data;
#define SPI_DO (spi & 0x01)

static void SPI_Write(uint8_t in)
{
	for (uint8_t i = 0; i < 8; ++i)
	{
		if (in & 0x80)
		{
			SPI_DI_1;
		}
		else
		{
			SPI_DI_0;
		}
		SPI_CLK_0;
		SPI_CLK_1;
		in <<= 1;
	}
}
static uint8_t SPI_Read(void)
{
	uint8_t out = 0;
	for (uint8_t i = 0; i < 8; ++i)
	{
		SPI_CLK_0;
		SPI_CLK_1;
		out <<= 1;
		out |= SPI_DO;
	}
	return out;
}

static uint8_t SPIFLASH_Busy(void)
{
	SPI_CS_0;
	SPI_Write(0x05);
	uint8_t r0 = SPI_Read();
	SPI_CS_1;
	return r0 & 0x01;
}
static uint32_t SPIFLASH_Status(void)
{
	SPI_CS_0;
	SPI_Write(0x05);
	uint32_t r0 = SPI_Read();
	SPI_CS_1;

	SPI_CS_0;
	SPI_Write(0x35);
	uint32_t r1 = SPI_Read();
	SPI_CS_1;

	SPI_CS_0;
	SPI_Write(0x15);
	uint32_t r2 = SPI_Read();
	SPI_CS_1;

	return (r2 << 16) | (r1 << 8) | (r0);
}
static void SPIFLASH_WriteEnable(void)
{
	SPI_CS_0;
	SPI_Write(0x06);
	SPI_CS_1;
}
static void SPIFLASH_Erase(uint32_t addr)
{
	SPIFLASH_WriteEnable();
	SPI_CS_0;
	SPI_Write(0x20);
	SPI_Write((addr >> 16) & 0xff);
	SPI_Write((addr >> 8) & 0xff);
	SPI_Write(addr & 0xff);
	SPI_CS_1;
	while (SPIFLASH_Busy());
}

int putchar(int c)
{
	while (uart_flag & 0x01);
	uart = c;
	return c;
}

static uint8_t __xdata buffer[20][120];
static inline void drawpixel(int16_t x, int16_t y)
{
	if (x < 0 || x > W - 1 || y < 0 || y > H - 1)
		return;
	buffer[x >> 3][y] |= (uint8_t)1 << (x & 7);
}
static inline void clear(void)
{
	for (uint8_t x = 0; x < 20; ++x)
	{
		for (uint8_t y = 0; y < 120; ++y)
		{
			buffer[x][y] = 0;
		}
	}
}
static inline void display(void)
{
	for (uint8_t x = 0; x < 20; ++x)
	{
		for (uint8_t y = 0; y < 120; ++y)
		{
			(*(uint8_t volatile __xdata*)((uint16_t)0x8000 + (uint16_t)x + (uint16_t)y * 256)) = buffer[x][y];
		}
	}
}
static const uint8_t hz16[][32] = 
{
	{0x08,0x08,0xfd,0xfc,0x10,0x88,0x10,0x88,0x20,0x88,0x20,0x88,0x7c,0x88,0xa7,0xfe,0x24,0x88,0x24,0x88,0x24,0x88,0x25,0x08,0x3d,0x08,0x22,0x08,0x04,0x08,0x00,0x08,},
	{0x01,0x00,0x01,0x08,0x7f,0xfc,0x01,0x00,0x3f,0xf8,0x01,0x00,0x01,0x04,0xff,0xfe,0x02,0x00,0x05,0x10,0x0c,0xa0,0x34,0x40,0xc4,0x30,0x05,0x0e,0x06,0x04,0x04,0x00,},
	{0x02,0x00,0x01,0x00,0x7f,0xfe,0x44,0x42,0x88,0x34,0x12,0x10,0x02,0x20,0x3f,0xf0,0x02,0x20,0x02,0x20,0x04,0x20,0x04,0x20,0x08,0x22,0x08,0x22,0x10,0x1e,0x60,0x00,},
	{0x00,0x04,0x04,0xfe,0x7e,0x84,0x44,0x84,0x44,0x84,0x44,0xfc,0x7c,0x84,0x44,0x84,0x44,0x84,0x44,0xfc,0x7c,0x84,0x44,0x84,0x01,0x04,0x01,0x04,0x02,0x14,0x04,0x08,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x00,},
	{0x00,0x00,0x40,0x08,0x37,0xfc,0x10,0x08,0x82,0x08,0x62,0x08,0x22,0x10,0x09,0x10,0x11,0x20,0x20,0xa0,0xe0,0x40,0x20,0xa0,0x21,0x10,0x22,0x08,0x24,0x0e,0x08,0x04,},
	{0x02,0x00,0x01,0x00,0x3f,0xfc,0x20,0x04,0x40,0x08,0x1f,0xe0,0x00,0x40,0x00,0x80,0x01,0x04,0xff,0xfe,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00,},
	{0x01,0x00,0x00,0x88,0x3f,0xfc,0x20,0x00,0x2f,0xf8,0x20,0x20,0x21,0x40,0x20,0x80,0x2f,0xfc,0x20,0x88,0x20,0x90,0x20,0x80,0x40,0x80,0x40,0x80,0x82,0x80,0x01,0x00,},
	{0x00,0x04,0x47,0xfe,0x54,0x20,0x54,0x44,0x55,0xfe,0x55,0x04,0x55,0x24,0x55,0x24,0x55,0x24,0x55,0x24,0x55,0x24,0x55,0x24,0x54,0x20,0x44,0x58,0x84,0x84,0x03,0x02,},
	{0x10,0x10,0x0c,0x30,0x04,0x40,0x3f,0xfc,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x24,0xff,0xfe,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20,},
	{0x00,0x04,0xff,0xfe,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x03,0x40,0x05,0x20,0x09,0x18,0x11,0x0c,0x21,0x04,0x41,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,},
	{0x02,0x00,0x01,0x00,0x7f,0xfe,0x40,0x02,0x80,0x24,0x1f,0xf0,0x01,0x00,0x01,0x00,0x11,0x20,0x11,0xf0,0x11,0x00,0x11,0x00,0x11,0x00,0x29,0x06,0x47,0xfc,0x80,0x00,},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
	{0x10,0x80,0x10,0x88,0x24,0x98,0x44,0xa0,0xfe,0xc0,0x02,0x84,0x7c,0x84,0x44,0x7c,0x7c,0x00,0x44,0x88,0x44,0x98,0x7c,0xa0,0x44,0xc0,0x44,0x82,0x54,0x82,0x48,0x7e,},
	{0x00,0x84,0x3f,0xc4,0x20,0x88,0x3f,0x90,0x20,0xa0,0x3f,0x84,0x04,0x04,0xff,0xe8,0x00,0x10,0x3f,0xa2,0x20,0x82,0x3f,0x84,0x15,0x08,0x24,0x90,0x54,0xa0,0x08,0x40,},
	{0x20,0x04,0x17,0xfe,0x50,0x04,0x44,0x44,0x42,0x84,0x4f,0xe4,0x48,0x24,0x48,0x24,0x4f,0xe4,0x4a,0xa4,0x42,0x84,0x42,0x94,0x44,0x94,0x48,0x74,0x50,0x04,0x40,0x0c,},
	{0x00,0x20,0x08,0x40,0x7c,0x84,0x4b,0xfe,0x4a,0x04,0x4a,0x04,0x4a,0xf4,0x4a,0x94,0x4a,0x94,0x4a,0x94,0x4a,0x94,0x7a,0xf4,0x4a,0x04,0x02,0x04,0x02,0x14,0x02,0x08,},
	{0x00,0x20,0x20,0x28,0x13,0xfc,0x10,0x20,0x00,0x20,0x07,0xfe,0xf0,0x92,0x10,0x54,0x11,0x10,0x10,0x94,0x17,0xfe,0x10,0x20,0x14,0x20,0x18,0x50,0x10,0x8c,0x03,0x04,},
};
static void drawHZ16(int16_t x, int16_t y, uint8_t idx)
{
	for (uint8_t k = 0; k < 16; k++)
	{
		for (uint8_t j = 0; j < 2; j++)
		{
			for (uint8_t i = 0; i < 8; i++)
			{
				if (hz16[idx][k * 2 + j] & (0x80 >> i))
					drawpixel(x + j * 8 + i, y + k);
			}

		}
	}
}
static uint8_t readHZK(uint32_t addr)
{
	SPI_CS_0;
	SPI_Write(0x03);
	SPI_Write((addr >> 16) & 0xff);
	SPI_Write((addr >> 8) & 0xff);
	SPI_Write(addr & 0xff);
	uint8_t ret = SPI_Read();
	SPI_CS_1;
	return ret;
}
#define FLASH_OFFSET 0x100000
void drawHZK16(int16_t x, int16_t y, uint8_t word0, uint8_t word1)
{
	const uint32_t offset = (94 * (uint32_t)(word0 - 0xa0 - 1) + (word1 - 0xa0 - 1)) * 32;
	for (uint8_t k = 0; k < 16; k++)
	{
		for (uint8_t j = 0; j < 2; j++)
		{
			for (uint8_t i = 0; i < 8; i++)
			{
				if (readHZK(FLASH_OFFSET + offset + k * 2 + j) & (0x80 >> i))
					drawpixel(x + j * 8 + i, y + k);
			}
		}
	}
}
void drawHZK16String(int16_t x, int16_t y, const char* s)
{
	uint8_t i = 0;
	while (s[i] != '\0')
	{
		drawHZK16(x + i * 8, y, s[i], s[i + 1]);
		i += 2;
	}
}
static uint8_t charbuffer[120];
static uint8_t charcount;
void main(void)
{
	printf_small("Hello, world!\n");
	spi_data = 0xff;

#if 1
	SPI_CS_0;
	SPI_Write(0x9F);
	uint8_t RDID[3];
	RDID[0] = SPI_Read();
	RDID[1] = SPI_Read();
	RDID[2] = SPI_Read();
	SPI_CS_1;
	printf("RDID:%02x%02x%02x\r\n", RDID[0], RDID[1], RDID[2]);

	SPI_CS_0;
	SPI_Write(0x4B);
	SPI_Write(0);
	SPI_Write(0);
	SPI_Write(0);
	SPI_Write(0);
	uint8_t UID[8];
	UID[0] = SPI_Read();
	UID[1] = SPI_Read();
	UID[2] = SPI_Read();
	UID[3] = SPI_Read();
	UID[4] = SPI_Read();
	UID[5] = SPI_Read();
	UID[6] = SPI_Read();
	UID[7] = SPI_Read();
	SPI_CS_1;
	printf("UID:%02x%02x%02x%02x%02x%02x%02x%02x\r\n", UID[0], UID[1], UID[2], UID[3], UID[4], UID[5], UID[6], UID[7]);
#endif

#define VGACOLOR 0X9b43
	//vgacolorL = VGACOLOR & 0xff;
	//vgacolorH = (VGACOLOR >> 8) & 0xff;

	uint16_t vgacolor;
	vgacolor = 0;

	uint8_t r, g, b;
	r = (VGACOLOR >> 11) & 0x1f;
	g = (VGACOLOR >> 5) & 0x3f;
	b = (VGACOLOR >> 0) & 0x1f;

	uint8_t rf, gf, bf;
	rf = 0;	gf = 0;	bf = 0;

	clear();
#if 0
	for (uint8_t i = 0; i < 9; ++i)
	{
		uint8_t x = 8 + i * 16;
		drawHZ16(x, 32, i);
		drawHZ16(x, 64, i + 9);
	}
#else
	drawHZK16String(8, 32, "研表究明，汉字序顺");
	drawHZK16String(8, 64, "并不定一能影阅响读");
#endif
	display();

	uint8_t vblank;
	vblank = 0;
	uint8_t hblank;
	hblank = 0;

	uint16_t hblank_count;
	hblank_count = 0;
	uint16_t vblank_count;
	vblank_count = 0;

	charcount = 0;
	
	while (1)
	{
		if (uart_flag & 0x02)
		{
			const uint8_t c = (uint8_t)uart;
			if (c != 0x0a)
			{
				charbuffer[charcount++] = c;
			}
			if (c == 0x0d || charcount == 120)
			{
				uint8_t x, y;
				x = 0; y = 0;
				clear();
				for (uint8_t i = 0; i < charcount / 2; ++i)
				{
					const uint8_t w0 = charbuffer[2 * i + 0];
					const uint8_t w1 = charbuffer[2 * i + 1];
					drawHZK16(x, y, w0, w1);
					x += 16;
					if (x >= W)
					{
						x = 0;
						y += 20;
					}
				}
				display();
				charcount = 0;
			}
		}

		const uint8_t HV = vgaHV;
		const uint8_t vsync = !(HV & 0x01);
		const uint8_t hsync = !(HV & 0x02);
		if (vblank == 0 && vsync)
		{
			vblank = 1;
			if (vblank_count++ == 5)
			{
				vblank_count = 0;
				if (r == 0) rf = 0;
				if (g == 0) gf = 0;
				if (b == 0) bf = 0;

				if (r == 0x1f) rf = 1;
				if (g == 0x3f) gf = 1;
				if (b == 0x1f) bf = 1;

				if (rf) r--; else r++;
				if (gf) g--; else g++;
				if (bf) b--; else b++;

				vgacolor = ((uint16_t)r << 11) | ((uint16_t)g << 5) | (uint16_t)b;
				vgacolorL = vgacolor & 0xff;
				vgacolorH = (vgacolor >> 8) & 0xff;
			}
		}
		if (vblank == 1 && !vsync)
		{
			vblank = 0;
		}
	}
}
